package robot;

import kareltherobot.*;

define a new robot module called BetterBot which is an extension of the orignal Robot module{
	defining the betterBot here

	define turnRight()
	{
		turnLeft();
		turnLeft();
		turnLeft();
	}

	define a int function pickAllBeepersAndCount()
	{
		int beepersCollected = 0;
		while next to a beeper
		{
			pickBeeper
			add the counting var by 1 to count the beeper we just picked
		}
		return beepersCollected;
		/*
		tips:
		
		return means it will return a value, so you can use it like a variable or a value.
		for example you can do int x = roomba.pickAllBeepersAndCount();
		or you can do totalBeepers = totalBeepers + roomba.pickAllBeepersAndCount();
		
		*/
		
		}

/*
here is an example of a function that does not return a value

*/
	define a void funtion pickAllBeepers()
	{
		while next to a beeper
		{
			pickBeeper
		}
		//void means it does not return a value, so you can only call it like a statement
		//for example you can do roomba.pickAllBeepers(); like how you do a roomba.move();
		//but you cant do int x = roomba.pickAllBeepers();
		//or totalBeepers = totalBeepers + roomba.pickAllBeepers();
		//in the program we will not use this function, but its just to give a demonstration on void function and return function
	}

}

public class Roomba implements Directions
{
	public static void main(String[] args)
	{
		// this is the main function, the program will start running from here

		// this is to test different worlds in a convienient way
		// you can remove comment sign to change the world you want to test
		//String worldName = "robot/TestWorld-1.wld";
		//String worldName = "robot/TestWorld-2.wld";
		//String worldName = "robot/basicRoom.wld";
		String worldName = "robot/finalTestWorld2024.wld";
		

		Roomba cleaner = new Roomba();


		//the following are different test world conditions, it will call the cleanRoom function with different parameters, you will see the how the cleanRoom function is defined very soon
		//basicRoom
		//int totalBeepers = cleaner.cleanRoom(worldName, 7, 6);
		//TestWorld1
		//int totalBeepers = cleaner.cleanRoom(worldName, 25, 16);
		//TestWorld2
		//int totalBeepers = cleaner.cleanRoom(worldName, 5, 6);
		//FinalTestWorld
		int totalBeepers = cleaner.cleanRoom(worldName, 26, 101);

	}

	//so here is the cleanRoom function, it will return an int value which is the total number of beepers it have picked up
	//it takes 3 parameters, the name of the world file, the starting X position and the starting Y position
	public int cleanRoom(String worldName, int startX, int startY)
	{
		BetterBot roomba = new BetterBot(startX, startY, East, 67);
		//this was defined in the BetterBot module, it will create a new BetterBot object called roomba
		//it will start at the position (startX, startY), facing East,

		//this is the debugging settings, so I have 2 different traveling patterns for the roomba, and to switch between them in a convienient way I use a variable to set the pattern. This should not be changing during the program
		// debug settings
		int travelingPattern = 2;

		// World settings
		World.readWorld(worldName);
		World.setVisible(true);
		World.setDelay(0);


		// variables initialize
		int totalBeepers = 0;
		boolean finish = false;
		int area = 0;
		// to find the area, we can simply do it by adding 1 to our counting variable
		// each time our bot moves to a new gird, which is every move for pattern 1, and
		// all the move expect the ones moving backwards for pattern 2
		area++;
		// in this way we didnt count the area for our inital grid, so we have to add
		// area by one here

		int pileNumber = 0;
		// Explain it here
		// to find the number of pile, we can simply do it by adding 1 to our counting variable after each time our bot pick up beepers from a new pile
		// so each time our bot tries pick up beepers, we check if the number of beepers picked up is more than 0, if so we add pileNumber by 1
		int biggestPileNumber = 0;
		// for the biggestPileNumber we can check each time after our bot pick up beepers, if the number of beepers pickein that piled up is more than biggestPileNumber, then we update biggestPileNumber to be the number of beepers picked up this time
		int biggestPilePositionX = 0;
		int biggestPilePositionY = 0;

		// temp variables
		int currentPileBeeperNumber = 0;
		int biggestPileRawPositionX = 0;
		int biggestPileRawPositionY = 0;
		double averagePileSize=0;
		double percentDirty=0;
		// we want the position from the top left corner, but before the program is done
		// we dont know where it is, but we have to record the position though out our
		// program, so we keep a raw data

		int SmallestRoombaPositionX = Integer.MAX_VALUE;
		int biggestRoombaPositionY = -1;
		//they are actually the position of the left up corner
		currentPileBeeperNumber = roomba.pickAllBeepersAndCount();
					if (currentPileBeeperNumber > biggestPileNumber)
					{
						biggestPileNumber = currentPileBeeperNumber;
						biggestPileRawPositionX = roomba.avenue();
						biggestPileRawPositionY = roomba.street();
					}
					if (currentPileBeeperNumber > 0)
					{
						pileNumber++;
					}
					totalBeepers = totalBeepers + currentPileBeeperNumber;
		while (!finish)
		{
			// if we are not finished

			// we have 2 ways to do it now, we can either do zig zag or clear a line and go
			// back and go to the next line, like the ladder E.
			// the first way is relatively hard to write but require less work for the bot
			// the second way is realtively easier to write, but our roomba will have to do
			// extra work

			// first way
			if (travelingPattern == 1)
			{
				while (roomba.frontIsClear())
				{
					currentPileBeeperNumber = roomba.pickAllBeepersAndCount();
					if (currentPileBeeperNumber > biggestPileNumber)
					{
						biggestPileNumber = currentPileBeeperNumber;
						biggestPileRawPositionX = roomba.avenue();
						biggestPileRawPositionY = roomba.street();
					}
					if (currentPileBeeperNumber > 0)
					{
						pileNumber++;
					}
					totalBeepers = totalBeepers + currentPileBeeperNumber;
					// remember how roomba.pickAllBeepersAndCount is defined? Its gonna return the
					// number of the beeper it have collected.

					// can also write in this way
					// totalBeepers += roomba.pickAllBeepersAndCount();

					roomba.move();
					if (roomba.street() > biggestRoombaPositionY)
					{
						biggestRoombaPositionY = roomba.street();
					}
					if (roomba.avenue() < SmallestRoombaPositionX)
					{
						SmallestRoombaPositionX = roomba.avenue();
					}
					area++;
				}
				// if the program run till here it means front is not clear, else it should
				// still be looping in the while
				// in this case we can assume its running into a wall

				boolean facingEast = true;
				if (roomba.facingEast())
				{
					roomba.turnLeft();
				}
				else
				{
					roomba.turnRight();
					facingEast = false;
				}
				if (roomba.frontIsClear())
				{
					roomba.move();
					if (roomba.street() > biggestRoombaPositionY)
					{
						biggestRoombaPositionY = roomba.street();
					}
					if (roomba.avenue() < SmallestRoombaPositionX)
					{
						SmallestRoombaPositionX = roomba.avenue();
					}
					area++;
				}
				else
				{
					// another tricky but unconvensional way to get the corner position is this
					// cornerRawPositionY=roomba.street();
					finish = true;
				}

				currentPileBeeperNumber = roomba.pickAllBeepersAndCount();
				if (currentPileBeeperNumber > biggestPileNumber)
				{
					biggestPileNumber = currentPileBeeperNumber;
					biggestPileRawPositionX = roomba.avenue();
					biggestPileRawPositionY = roomba.street();
				}
				if (currentPileBeeperNumber > 0)
				{
					pileNumber++;
				}
				totalBeepers = totalBeepers + currentPileBeeperNumber;
				if (facingEast)
				{
					roomba.turnLeft();
				}
				else
				{
					roomba.turnRight();
				}
			}

			else if (travelingPattern == 2)
			{
				while (roomba.frontIsClear())
				{

					roomba.move();
					if (roomba.street() > biggestRoombaPositionY)
					{
						biggestRoombaPositionY = roomba.street();
					}
					if (roomba.avenue() < SmallestRoombaPositionX)
					{
						SmallestRoombaPositionX = roomba.avenue();
					}
					area++;

					currentPileBeeperNumber = roomba.pickAllBeepersAndCount();
					if (currentPileBeeperNumber > biggestPileNumber)
					{
						biggestPileNumber = currentPileBeeperNumber;
						biggestPileRawPositionX = roomba.avenue();
						biggestPileRawPositionY = roomba.street();
					}
					if (currentPileBeeperNumber > 0)
					{
						pileNumber++;
					}
					totalBeepers = totalBeepers + currentPileBeeperNumber; // remember how roomba.pickAllBeepersAndCount
																			// is defined? Its gonna return the
					// number of the beeper it have collected.

					// can also write in this way
					// totalBeepers += roomba.pickAllBeepersAndCount();
				}
				roomba.turnRight();
				roomba.turnRight();
				while (roomba.frontIsClear())
				{
					roomba.move();
					if (roomba.street() > biggestRoombaPositionY)
					{
						biggestRoombaPositionY = roomba.street();
					}
					if (roomba.avenue() < SmallestRoombaPositionX)
					{
						SmallestRoombaPositionX = roomba.avenue();
					}
				} // dont have to check if there's beepers as we are going the same way back
				roomba.turnRight();
				if (roomba.frontIsClear())
				{

					roomba.move();
					if (roomba.street() > biggestRoombaPositionY)
					{
						biggestRoombaPositionY = roomba.street();
					}
					if (roomba.avenue() < SmallestRoombaPositionX)
					{
						SmallestRoombaPositionX = roomba.avenue();
					}
					area++;
					currentPileBeeperNumber = roomba.pickAllBeepersAndCount();
					if (currentPileBeeperNumber > biggestPileNumber)
					{
						biggestPileNumber = currentPileBeeperNumber;
						biggestPileRawPositionX = roomba.avenue();
						biggestPileRawPositionY = roomba.street();
					}
					if (currentPileBeeperNumber > 0)
					{
						pileNumber++;
					}
					totalBeepers = totalBeepers + currentPileBeeperNumber;
					roomba.turnRight();
				}
				else
				{
					// if you are not brave enough to take the challenge those two also get you the
					// corner position, try to think about why
					// cornerRawPositionX=roomba.avenue();
					// cornerRawPositionY=roomba.street();
					finish = true;
				}
			}
		}
		currentPileBeeperNumber = roomba.pickAllBeepersAndCount();
					if (currentPileBeeperNumber > biggestPileNumber)
					{
						biggestPileNumber = currentPileBeeperNumber;
						biggestPileRawPositionX = roomba.avenue();
						biggestPileRawPositionY = roomba.street();
					}
					if (currentPileBeeperNumber > 0)
					{
						pileNumber++;
					}
					totalBeepers = totalBeepers + currentPileBeeperNumber;

		// convert raw biggest pile position into the position we want
		biggestPilePositionX=biggestPileRawPositionX-SmallestRoombaPositionX;
		biggestPilePositionY=biggestRoombaPositionY-biggestPileRawPositionY;


		averagePileSize=(double)(totalBeepers)/(double)(pileNumber);
		percentDirty=(double)(pileNumber)/(double)(area);
		//output
		System.out.println("Area is " + area);
		System.out.println("Number of pile is " + pileNumber);
		System.out.println("Number of beeper is " + totalBeepers);
		System.out.println("Biggest pile have " + biggestPileNumber + " of beepers");
		System.out.println("Biggest pile from top left corner is right " + biggestPilePositionX + " and down " + biggestPilePositionY);
		System.out.println("The average pile size is " + averagePileSize);
		System.out.println("Percent dirty is " + percentDirty);
		return totalBeepers;
	}

	

}